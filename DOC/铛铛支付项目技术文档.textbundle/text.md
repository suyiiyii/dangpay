# 铛铛支付

[toc]



## 项目简介

数字货币成为越来越多人的支付方式选择，一个安全高效，功能丰富的资金管理网站可以更好地满足用户的需求，可以让用户更好地管理自己的资金，确认资金明细。

铛铛支付是一个面向企业的兼信息展示，用户管理等的多功能支付平台，为企业的数字化转型赋能。



## 设计思路

整体采用前后端分离架构设计，旨在实现系统的高可扩展性、灵活性和可维护性。前端采用响应式设计，能够适应不同设备和屏幕尺寸，提供用户友好的交互体验。后端采用分布式架构，各个组件之间通过API进行交互，实现了系统的松耦合和高内聚。

在支付平台的设计中，遵循了面向服务的架构（SOA）思想和MVC思想，各个业务模块之间通过服务接口进行交互，实现了系统的模块化和可重用性。

此外，还考虑到了系统的安全性和可靠性，采用了多种安全机制和故障恢复机制，确保了系统的稳定运行和数据安全。



## 详细功能设计

我的项目主要使用了以下技术栈：

**HTTP Server**

- 采用 Java Servlet 构建 RESTful API，提供了统一的接口规范，实现了与客户端的交互。
- 该技术栈的使用实现了项目的核心功能，即在线支付平台的支付处理和订单管理。

**数据库**

- 使用 MySQL 作为项目的数据库管理系统，存储了订单信息、用户信息、支付记录等关键数据。
- 该技术栈的使用实现了项目的数据存储和管理功能，确保了数据的安全和可靠性。

**文件存储**

- 使用自建的 Minio 提供 S3 接口，实现了文件的存储和管理。
- 该技术栈的使用实现了项目的文件存储功能，例如存储支付凭证、订单合同等文件。

**缓存和分布式锁**

- 使用 Redis 作为项目的缓存和分布式锁机制，实现了高性能的数据缓存和并发控制。
- 该技术栈的使用实现了项目的性能优化和高可用性功能，例如缓存热点数据、控制并发支付请求等。

**应用架构**

- 将应用设计为无状态的，实现了应用的水平扩展和高可用性。
- 该技术栈的使用实现了项目的可扩展性和高可用性功能，例如支持高并发支付请求、快速故障恢复等。

**容器化和部署**

- 使用 Kubernetes（K8s）作为项目的容器化和部署平台，实现了自动化的部署、扩展和管理。
- 该技术栈的使用实现了项目的自动化运维和高可用性功能，例如自动扩展容器、滚动更新等。

**高可用性和自动扩展**

- 配置了 Horizontal Pod Autoscaling（HPA），实现了根据负载自动扩展容器的数量。
- 配置了 Service（Svc），实现了服务发现和负载均衡。
- 该技术栈的使用实现了项目的高可用性和自动扩展功能，例如自动扩展容器、负载均衡等。

## 项目功能

项目主要有主页，群组，钱包，私聊，交易记录，审计日志六个页面组成。

#### 主页

主页有注册，登录，注销登录，以及登录之后查看和修改个人信息的功能。

![image-20240429120546182](assets/image-20240429120546182.png)

![image-20240429120637515](assets/image-20240429120637515.png)

#### 群组页面

有查看群组列表，创建群组和查看我的群组功能。

创建群组将会向网站管理员发送申请，管理员审批通过即成功创建群组。

![image-20240429120922179](assets/image-20240429120922179.png)

网站管理员会比普通用户多出来可以封禁群组和解封群组的功能，被封禁的群组无法做任何操作，同时群组钱包会被冻结，无法进行交易，只能由群组管理员向网站管理员申请解封。

![image-20240429131202427](assets/image-20240429131202427.png)



##### 群组详细页面

用户可以查看自己的群组的详细信息

![image-20240429122236442](assets/image-20240429122236442.png)

群组管理员会比普通的群组成员多出管理方面的功能

![dangpay.99.suyiiyii.top_ (1)](assets/dangpay.99.suyiiyii.top_ (1).png)

群组的钱包系统分为群组主钱包和群组子钱包，主钱包归属于群组，不属于任何个人，无法使用群组主钱包直接对外进行交易。群组管理员可以给群组成员分配群组子钱包，子钱包归属于个人，和个人钱包一样，可以进行任何交易，同时可以接受群组主钱包分配和收回资金。如果群组管理员希望给其他成员分配资金，则可以给对应的群组子钱包转钱，然后讲自己的子钱包的钱转移到群组主钱包里，然后再用群组主钱包划分资金给需要分配的用户的群组子钱包。

#### 钱包页面

![dangpay.99.suyiiyii.top_](assets/dangpay.99.suyiiyii.top_.png)

钱包界面可以看到钱包的详细信息，可以生成收款二维码，可以扫描其他用户提供的收款二维码，可以查看该钱包的交易记录

#### 私聊页面

![image-20240429125550801](assets/image-20240429125550801.png)

用户可以在这里接收和处理系统通知，和其他用户以及群组内聊天

#### 全局交易记录

管理员可以在这个页面看到站内的所有交易记录，便于监管。

![image-20240429130439225](assets/image-20240429130439225.png)

#### 审计日志

管理员可以查看全站的审计日志，便于查找恶意用户。

![image-20240429130553723](assets/image-20240429130553723.png)




## 项目亮点

### 项目代码亮点



#### 连接池

自己实现了jdbc的连接池，可以适配不同的数据库驱动，通过多线程实现高效的连接分配和收回操作，大大提高了连接的复用率，加速数据库操作，同时为orm框架的完成奠定基础。



#### ORM

自己实现了一个简单的orm框架，具有自动根据实体类创建对应的数据库表，语义化的增删差改操作，批量插入对象，自动追踪被修改的元素并自动更新到数据库等功能。语句的执行起和查询条件的构造器使用回调函数实现了分离，并且支持链式调用，扩展性强。使用简单的java对象操作即可实现操作数据库，大大的提高了开发的效率。

```java
// 获取Session
Session db = modelManger.getSession();
// 单个查询
Student student = db.query(Student.class).eq("studentid", studentid).first();
// 批量查询
List<Student> list = db.query(Student.class).limit(page, size).all();

// 单个插入
student.studentid = "ididid";
student.grade = 1000;
db.insert(student);

// 批量插入
List<Student> students;
for (int i = 0; i < 10; i++) {
     db.add(student);
}
db.commit();

// 更新
student = db.query(Student.class).eq("studentid", studentid).first();
student.grade = 999;
db.commit();

// 删除
db.query(Student.class).eq("studentid", studentid).delete();
```

```mermaid
classDiagram
%%    ConnectionManger *-- ModelManger
    class ModelManger {
        <<singleton>>
        +ModelManger(String, ConnectionBuilder)
        +getSession(): Session
        +ConnectionManger connectionManger
        +List<> tables
    }

    class ConnectionManger {
        <<singleton>>
        +ConnectionManger(ConnectionBuilder)
        +getSqlExecutor(): SqlExecutor
        -ConnectionPool pool
    }

    class SuConnectionPool {
        -List<> pool
        +getConnection(): Connection
        +releaseConnection(Connection)
    }

    class Session {
        +Session(modelManger)
        +query(): Wrapper
        +update(): Wrapper
        +delete(): Wrapper
        +commit()
        -SqlExecutor sqlExecutor
    }

    ModelManger --* ConnectionManger
    ModelManger --|> Session: getSession()
    Session --* SqlExecutor
    SqlExecutor --* Connection
    Session --> ConnectionManger: getSqlExecutor()
    ConnectionManger --> Session: sqlExecutor
    ConnectionManger --o SuConnectionPool
    Session --> Wrapper: query()/update()/delete()
    Wrapper --> Session: execute()
```



#### IOC/DI/AOP

自己实现了一个简单的IOC容器，支持依赖注入和创建代理对象。

* 支持对象的生命周期管理，构建时自动注入需要的参数，销毁时调用destroy方法优雅的释放占用的资源。
* 支持构造器注入，自动构建构造方法需要的对象，如果有嵌套则递归构建。
* 支持AOP编程，支持在构造对象时注入被代理的对象，在不修改原来代码的情况下，在调用对象的方法的时候插入新的逻辑。以此为基础实现了rbac权限认证和统一的审批系统以及声明式事务和锁。
* 使用注解优化上述过程，使得代码更加优雅。

#### RBAC
使用基于AOP的带有分组拓展的RBAC权限认证系统。
* 权限认证整体框架基于RBAC，给不同的用户分配不同的角色。为了更好的应对群组关系，个人在rbac的基础上拓展了分组系统，用户将会被分配一个带有分组的角色，该角色只有操作分组内资源的的权限。
* 基于AOP，在方法被执行之前自动使用用户身份和用户的角色进行权限校验，无需在方法内部添加额外的代码。

#### 审批系统

基于AOP实现统一的审批系统，无需更改接口即可将旧接口改为需要审批。
实现原理：
* 在权限校验的时候设置断点，记录请求的方法和参数，保存请求的原因后直接返回，告知用户请求已提交，等待审批
* 给审批人发送通知，审批人可以看到请求的原因，审批通过后，再执行操作
* 审批的消息带有一个回调地址，审批通过，前端调用回调地址，后端执行操作
* 通过请求的方法和参数，再次调用一次请求，但是这次不会再次进入权限校验，直接执行操作，不会再走请求流程

#### 子钱包设计
群组给用户分配资金，抽象为用户获得群组子钱包，子钱包同为钱包，可以正常与其他账户进行交易。

#### 声明式事务和锁

一行注解，即可给当前方法开启事务或锁

![image-20240429091843971](assets/image-20240429091843971.png)




#### 交易协议

基于开放共赢的理念，我设计了一套开放的通用的跨平台的交易api，在保证交易安全的前提下可以实现跨多平台的安全互信，为平台发展提供了更多可能性。

##### 网上付款

###### 场景

* 用户网上购物，下订单后网页弹出二维码，用户使用铛铛支付扫描二维码直接提示金额，身份认证通过后付款

收款方生成二维码，给定金额，付款方扫描二维码进行付款

```mermaid
sequenceDiagram
    participant A as 用户
    participant B as 铛铛支付
    participant C as 第三方支付平台
    A ->> C: 扫描二维码
    C ->> A: 第三方的回调地址
    A ->> B: 第三方的回调地址
    B ->> C: 校验支付回调地址有效性
    C ->> B: 当前接口状态（带有所需要的金额）
    B -> B: 检查余额
    B ->> A: 允许支付
    A ->> B: 身份验证
    B -> B: 创建交易，冻结资金
    B ->> C: 发起支付请求
    C -> C: 创建交易（未完成）
    C ->> B: 支付结果
    B ->> C: ACK
    C -> C: 交易成功
    B -> B: 交易成功
    B ->> A: 交易完成
```

##### 收款码

###### 场景

* 项目作者在宿舍门口卖炒粉，贴一张收款码在门口，用户使用铛铛支付扫描收款码，手动输入金额，身份认证通过后付款

收款方生成收款码，付款方扫描收款码进行付款

收款码付款，用户使用铛铛支付扫描第三方支付平台的收款码，手动输入金额，进行付款

```mermaid
sequenceDiagram
    participant A as 用户
    participant B as 铛铛支付
    participant C as 第三方支付平台
    A ->> C: 扫描收款码
    C ->> A: 第三方的回调地址（带有待入账的钱包id
    A ->> B: 第三方的回调地址
    B ->> C: 校验支付回调地址有效性
    C ->> B: 当前接口状态
    B ->> A: 允许支付
    A ->> B: 手动输入金额，身份验证
    B -> B: 创建交易，冻结资金
    B ->> C: 发起支付请求
    C -> C: 创建交易（未完成）
    C ->> B: 支付结果
    B ->> C: ACK
    C -> C: 交易成功
    B -> B: 交易成功
    B ->> A: 交易完成
```

##### 付款码

###### 场景

* 用户去超市购物，收银员输入金额，用户使用铛铛支付，在身份认证之后出示付款码，收银员扫描付款码，此时不需要身份验证，直接付款

付款方生成付款码，收款方扫描付款码进行收款

付款码收款，用户设置收款金额，使用铛铛支付扫描第三方支付平台的付款码，进行收款

```mermaid
sequenceDiagram
    participant A as 用户
    participant B as 铛铛支付
    participant C as 第三方支付平台
    A ->> A: 设置收款金额
    A ->> C: 扫描付款码
    C ->> A: 第三方的回调地址（带有待入账的钱包id）
    A ->> B: 第三方的回调地址
    B ->> C: 校验支付回调地址有效性
    C ->> B: 当前接口状态
    B -> B: 创建交易
    B ->> C: 发起交易请求
    C -> C: 处理交易
    C ->> B: 交易结果
    B ->> C: ACK
    C -> C: 交易成功
    B -> B: 交易成功
    B ->> A: 收款成功
```

##### Api

###### Post /requestTransaction?identity=xxx

请求交易，返回当前接口的状态和回调地址

identity 是二维码的标识，应该是唯一且随机的

###### Request

####### header

```header
X-Signature: string
```

####### body

```json
{
  "platform": "string",
  "requestId": "string"
}
```

header应该包含一个签名，签名内容为body的json字符串，签名算法为rsa，私钥由铛铛支付平台持有，公钥由第三方支付平台持有

###### Response

####### success(未指定金额)

```json
{
  "status": "success",
  "callback": "/startTransaction?code=xxx",
  "isAmountSpecified": false,
  "payeeName": "string",
  "requestId": "string"
}
```

####### success(指定金额)

表示希望对方转给自己的钱，正数为收款，负数为付款（主体为响应方）

```json
{
  "status": "success",
  "message": "success",
  "platform": "string",
  "callback": "/startTransaction?code=xxx",
  "isAmountSpecified": true,
  "specifiedAmount": 100,
  "payeeName": "string",
  "requestId": "string"
}
```

code 是表示交易对象的标识，应该是在收到对方的交易请求后生成的，应该是系统临时生成且具有有效期的

介绍到请求之后应返回相同的requestId，标记请求和响应，便于后续的交易记录查询

####### error

```json
{
  "status": "error",
  "message": "error message",
  "requestId": "string"
}
```

##### Post /startTransaction?code=xxx

开始交易，表示希望转给对方的金额，正数为支付，负数为收款（主体为请求方）

###### Request

```json
{
  "platform": "string",
  "tradeDescription": "string",
  "payeeName": "string",
  "amount": 100,
  "requestId": "string"
}
```

###### Response

####### success

```json
{
  "status": "success",
  "message": "交易成功",
  "callbackUrl": "string",
  "requestId": "string"
}
```

####### error（code不存在或已过期）

```json
{
  "status": "error",
  "message": "code不存在或已过期",
  "requestId": "string"
}
```

##### Post /ack?code=xxx

为确保平台成功收到交易的响应，需要确认交易
确认交易
无请求体，响应200即可

如果ack请求失败，需要重发ack，或者等待管理员处理



### 项目开发亮点

#### 应用程序的无状态

简单介绍架构演进过程

##### 原始的单体架构

应用服务器需要处理客户端的各种请求，可能需要长期保存文件或者临时保存文件，一般数据库会独立出来部署到其他地方，但是其他数据一般都会保存在本地。

![下载](assets/下载.png)

##### 职能外包

可以将不同的功能转移给专用的中间件进行处理，可以讲应用本体无状态化。

![未命名绘图.drawio (1)](assets/未命名绘图.drawio (1).png)

##### 容器化

由于应用服务器不再需要本地存储数据，所以可以将应用服务器打包成容器镜像。

![未命名绘图.drawio (2)](assets/未命名绘图.drawio (2).png)

##### 集群部署

应用保持无状态后并使用容器打包后，便可以很方便的横向扩容，可以使用编排平台进行集群部署。

![未命名绘图.drawio (3)](assets/未命名绘图.drawio (3).png)



#### 项目架构

项目整体架构如下，整体部署在kubernetes集群上。

##### 应用

* 应用使用tomcat容器为基础，容器化部署。

##### 中间件

* **TiDB** 数据库中间件，提供结构化数据存储的能力，以兼容 `mysql 8.0` 的接口的形式提供服务，用于存储平台产生的绝大多数数据。
* **Redis** 缓存中间件，提供快速的的内存kv数据库的能力，用于临时存储邮箱验证码，交易凭据等临时数据。
* **MinIO** 存储中间件，提供高效存储非结构化数据的能力，用户存储用户上传的头像等二进制文件，以`S3`兼容接口的形式提供。

##### 负载均衡

* **traefik** 网络路由中间件，为集群提供负载均衡功能。

##### 容器编排

* **Kubernetes** 容器编排平台，它提供了自动化部署、扩展和管理容器化应用程序的能力，并且可以无缝地扩展或缩减应用程序的实例数量。



![导出 (1)](assets/导出 (1).png)



#### GitOps工作流

项目使用GitOps工作流，程序运行环境也使用代码定义，实现基础架构即代码(IaC) ，从而将基础架构的配置和管理自动化，提高了开发效率和系统可靠性。同时，GitOps工作流还提供了版本控制和回退机制，确保了系统的稳定性和可追溯性。

![导出 (2)](assets/导出 (2).png)

### 项目功能亮点

#### 全局审计日志

系统在做权限认证的同时会记录用户信息以及认证结果和请求相关信息并存储到数据库中，可以分析用户行为，识别恶意请求。

![image-20240429120219733](assets/image-20240429120219733.png)

#### HTTPS

用户请求从浏览器到中转服务器到应用服务器，全程 `HTTPS/TLS` 加密。

![未命名绘图.drawio (4)](assets/未命名绘图.drawio (4).png)



#### RSA 签名

平台之间交互必须使用私钥对请求体进行签名，接收交易请求方将会使用内置的公钥尝试验签，如签名不存在或验签失败，则拒绝响应。

![未命名绘图.drawio (5)](assets/未命名绘图.drawio (5).png)



#### 二维码支付

平台支持扫描二维码和生成二维码，极大的提高了支付的便利性。

![image-20240429092620969](assets/image-20240429092620969.png)





### 还有亿些项目亮点

* 邮箱验证码
* 人机验证码
* Jwt做登录状态
* 支持用户上传自己的头像和文件
* 全程日志记录
* 全自动参数校验
* 统一异常处理
* 使用Apifox记录接口信息
* 抵御Sql注入、Xss攻击
* 数据库用户密码加盐存储
* Git 使用双分支开发，dev分支定时合并到主分支
* Git提交粒度小
* ……





## 项目难点

### 第三方是什么

如果是类似于支付宝/微信支付的第三方，那么请求支付需要跳转到第三方平台，并且使用第三方的账号系统，使用第三方的资金。那么我的平台作为一个支付平台似乎就显得不那么重要了。

所以我根据调用第三方接口这个底线，将我自己的平台作为中心，提供了一套可以与其他支付平台进行交易的接口。用户支付时仍然使用我方平台，与第三方平台的交互将由我方服务器自己实现，这样隔离了用户和第三方，用户无需知晓第三方平台的存在，无需用户拥有第三方平台的账号，无需在第三方平台上面存款也可以与第三方平台上面的账户进行交易。



## 心得体会

这次项目非常的时间紧任务重，到目前为止还有很多没有完成的内容，但通过这次项目，我学到了许多宝贵的经验和知识。从项目的设计到实现，从技术选型到架构设计，每一个步骤都让我收获了很多。

在这个项目中，我深入了解了云原生架构的设计理念和实现方法，熟悉了 Kubernetes、Redis、S3 等技术的使用和配置。同时，我也学习到了如何设计和实现高可用、高性能的系统，如何进行性能优化和故障恢复。

在这里，我要特别感谢师兄吗，他们提供了宝贵的指导和支持，帮助我克服了许多技术难题和项目挑战。他们的经验和建议让我受益匪浅，我将永远感激他们的帮助和支持。

总之，这次项目让我成长了很多，让我学到了许多新的技术和经验，也让我更好地了解了自己的能力。我将继续努力，继续学习和成长，创造更多的价值。

